.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::Cache 3pm"
.TH Koha::Cache 3pm "2013-12-04" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::Cache \- Handling caching of html and Objects for Koha
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Koha::Cache;
\&  my $cache = Koha::Cache\->new({cache_type => $cache_type, %params});
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Koha caching routines. This class provides two interfaces for cache access.
The first, traditional interface provides the following functions:
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "new"
.IX Subsection "new"
Create a new Koha::Cache object. This is required for all cache-related functionality.
.SS "is_cache_active"
.IX Subsection "is_cache_active"
Routine that checks whether or not a caching system has been selected. This is
not an instance method.
.SS "set_in_cache"
.IX Subsection "set_in_cache"
.Vb 1
\&    $cache\->set_in_cache($key, $value, [$expiry]);
.Ve
.PP
Save a value to the specified key in the default cache, optionally with a
particular expiry.
.SS "get_from_cache"
.IX Subsection "get_from_cache"
.Vb 1
\&    my $value = $cache\->get_from_cache($key);
.Ve
.PP
Retrieve the value stored under the specified key in the default cache.
.SS "clear_from_cache"
.IX Subsection "clear_from_cache"
.Vb 1
\&    $cache\->clear_from_cache($key);
.Ve
.PP
Remove the value identified by the specified key from the default cache.
.SS "flush_all"
.IX Subsection "flush_all"
.Vb 1
\&    $cache\->flush_all();
.Ve
.PP
Clear the entire default cache.
.SH "TIED INTERFACE"
.IX Header "TIED INTERFACE"
Koha::Cache also provides a tied interface which enables users to provide a
constructor closure and (after creation) treat cached data like normal reference
variables and rely on the cache Just Working and getting updated when it
expires, etc.
.PP
.Vb 10
\&    my $cache = Koha::Cache\->new();
\&    my $data = \*(Aqwhatever\*(Aq;
\&    my $scalar = Koha::Cache\->create_scalar(
\&        {
\&            \*(Aqkey\*(Aq         => \*(Aqwhatever\*(Aq,
\&            \*(Aqtimeout\*(Aq     => 2,
\&            \*(Aqconstructor\*(Aq => sub { return $data; },
\&        }
\&    );
\&    print "$$scalar\en"; # Prints "whatever"
\&    $data = \*(Aqsomethingelse\*(Aq;
\&    print "$$scalar\en"; # Prints "whatever" because it is cached
\&    sleep 2; # Wait until the cache entry has expired
\&    print "$$scalar\en"; # Prints "somethingelse"
\&
\&    my $hash = Koha::Cache\->create_hash(
\&        {
\&            \*(Aqkey\*(Aq         => \*(Aqwhatever\*(Aq,
\&            \*(Aqtimeout\*(Aq     => 2,
\&            \*(Aqconstructor\*(Aq => sub { return $data; },
\&        }
\&    );
\&    print "$$variable\en"; # Prints "whatever"
.Ve
.PP
The gotcha with this interface, of course, is that the variable returned by
create_scalar and create_hash is a \fIreference\fR to a tied variable and not a
tied variable itself.
.PP
The tied variable is configured by means of a hashref passed in to the
create_scalar and create_hash methods. The following parameters are supported:
.IP "\fIkey\fR" 4
.IX Item "key"
Required. The key to use for identifying the variable in the cache.
.IP "\fIconstructor\fR" 4
.IX Item "constructor"
Required. A closure (or reference to a function) that will return the value that
needs to be stored in the cache.
.IP "\fIpreload\fR" 4
.IX Item "preload"
Optional. A closure (or reference to a function) that gets run to initialize
the cache when creating the tied variable.
.IP "\fIarguments\fR" 4
.IX Item "arguments"
Optional. Array reference with the arguments that should be passed to the
constructor function.
.IP "\fItimeout\fR" 4
.IX Item "timeout"
Optional. The cache timeout in seconds for the variable. Defaults to 600
(ten minutes).
.IP "\fIcache_type\fR" 4
.IX Item "cache_type"
Optional. Which type of cache to use for the variable. Defaults to whatever is
set in the environment variable \s-1CACHING_SYSTEM\s0. If set to 'null', disables
caching for the tied variable.
.IP "\fIallowupdate\fR" 4
.IX Item "allowupdate"
Optional. Boolean flag to allow the variable to be updated directly. When this
is set and the variable is used as an l\-value, the cache will be updated
immediately with the new value. Using this is probably a bad idea on a
multi-threaded system. When \fIallowupdate\fR is not set to true, using the
tied variable as an l\-value will have no effect.
.IP "\fIdestructor\fR" 4
.IX Item "destructor"
Optional. A closure (or reference to a function) that should be called when the
tied variable is destroyed.
.IP "\fIunset\fR" 4
.IX Item "unset"
Optional. Boolean flag to tell the object to remove the variable from the cache
when it is destroyed or goes out of scope.
.IP "\fIinprocess\fR" 4
.IX Item "inprocess"
Optional. Boolean flag to tell the object not to refresh the variable from the
cache every time the value is desired, but rather only when the \fIlocal\fR copy
of the variable is older than the timeout.
.SS "create_scalar"
.IX Subsection "create_scalar"
.Vb 1
\&    my $scalar = Koha::Cache\->create_scalar(\e%params);
.Ve
.PP
Create scalar tied to the cache.
.SH "EXPORT"
.IX Header "EXPORT"
None by default.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Koha::Cache::Object
.SH "AUTHOR"
.IX Header "AUTHOR"
Chris Cormack, <chris@bigballofwax.co.nz>
Paul Poulain, <paul.poulain@biblibre.com>
Jared Camins-Esakov, <jcamins@cpbibliography.com>
