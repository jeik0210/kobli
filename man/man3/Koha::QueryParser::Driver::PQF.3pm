.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Koha::QueryParser::Driver::PQF 3pm"
.TH Koha::QueryParser::Driver::PQF 3pm "2013-12-04" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Koha::QueryParser::Driver::PQF \- QueryParser driver for PQF
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Koha::QueryParser::Driver::PQF;
\&    my $QParser = Koha::QueryParser::Driver::PQF\->new(%args);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Main entrypoint into the QueryParser \s-1PQF\s0 driver. \s-1PQF\s0 is the Prefix Query
Language, the syntax used to serialize Z39.50 queries.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
In order to simplify Bib\-1 attribute mapping, this driver uses Class::Accessor
for accessing the following maps:
.IP "\fBbib1_field_map\fR \- search class/field Bib\-1 mappings" 4
.IX Item "bib1_field_map - search class/field Bib-1 mappings"
.PD 0
.IP "\fBbib1_modifier_map\fR \- search modifier mappings" 4
.IX Item "bib1_modifier_map - search modifier mappings"
.IP "\fBbib1_filter_map\fR \- search filter mappings" 4
.IX Item "bib1_filter_map - search filter mappings"
.IP "\fBbib1_relevance_bump_map\fR \- relevance bump mappings" 4
.IX Item "bib1_relevance_bump_map - relevance bump mappings"
.PD
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "get"
.IX Subsection "get"
Overridden accessor method for Class::Accessor. (Do not call directly)
.SS "set"
.IX Subsection "set"
Overridden mutator method for Class::Accessor. (Do not call directly)
.SS "add_bib1_field_map"
.IX Subsection "add_bib1_field_map"
.Vb 1
\&    $QParser\->add_bib1_field_map($class => $field => $server => \e%attributes);
\&
\&    $QParser\->add_bib1_field_map(\*(Aqauthor\*(Aq => \*(Aqpersonal\*(Aq => \*(Aqbiblioserver\*(Aq =>
\&                                    { \*(Aq1\*(Aq => \*(Aq1003\*(Aq });
.Ve
.PP
Adds a search field<\->bib1 attribute mapping for the specified server. The
\&\f(CW%attributes\fR hash contains maps Bib\-1 Attributes to the appropropriate
values. Not all attributes must be specified.
.SS "add_bib1_modifier_map"
.IX Subsection "add_bib1_modifier_map"
.Vb 1
\&    $QParser\->add_bib1_modifier_map($name => $server => \e%attributes);
\&
\&    $QParser\->add_bib1_modifier_map(\*(Aqascending\*(Aq => \*(Aqbiblioserver\*(Aq =>
\&                                    { \*(Aq7\*(Aq => \*(Aq1\*(Aq });
.Ve
.PP
Adds a search modifier<\->bib1 attribute mapping for the specified server. The
\&\f(CW%attributes\fR hash contains maps Bib\-1 Attributes to the appropropriate
values. Not all attributes must be specified.
.SS "add_bib1_filter_map"
.IX Subsection "add_bib1_filter_map"
.Vb 1
\&    $QParser\->add_bib1_filter_map($name => $server => \e%attributes);
\&
\&    $QParser\->add_bib1_filter_map(\*(Aqdate\*(Aq => \*(Aqbiblioserver\*(Aq =>
\&                                    { \*(Aqcallback\*(Aq => &_my_callback });
.Ve
.PP
Adds a search filter<\->bib1 attribute mapping for the specified server. The
\&\f(CW%attributes\fR hash maps Bib\-1 Attributes to the appropropriate values and
provides a callback for the filter. Not all attributes must be specified.
.SS "add_relevance_bump"
.IX Subsection "add_relevance_bump"
.Vb 2
\&    $QParser\->add_relevance_bump($class, $field, $server, $multiplier, $active);
\&    $QParser\->add_relevance_bump(\*(Aqtitle\*(Aq => \*(Aqexact\*(Aq => \*(Aqbiblioserver\*(Aq => 34, 1);
.Ve
.PP
Add a relevance bump to the specified field. When searching for a class without
any fields, all the relevance bumps for the specified class will be '\s-1OR\s0'ed
together.
.SS "target_syntax"
.IX Subsection "target_syntax"
.Vb 4
\&    my $pqf = $QParser\->target_syntax($server, [$query]);
\&    my $pqf = $QParser\->target_syntax(\*(Aqbiblioserver\*(Aq, \*(Aqauthor|personal:smith\*(Aq);
\&    print $pqf; # assuming all the indexes are configured,
\&                # prints \*(Aq@attr 1=1003 @attr 4=6 "smith"\*(Aq
.Ve
.PP
Transforms the current or specified query into a \s-1PQF\s0 query string for the
specified server.
.SS "date_filter_target_callback"
.IX Subsection "date_filter_target_callback"
.Vb 1
\&    $QParser\->add_bib1_filter_map($server, { \*(Aqtarget_syntax_callback\*(Aq => \e&Koha::QueryParser::Driver::PQF::date_filter_target_callback, \*(Aq1\*(Aq => \*(Aqpubdate\*(Aq });
.Ve
.PP
Callback for date filters. Note that although the first argument is the QParser
object, this is technically not an object-oriented routine. This has no
real-world implications.
.SS "_map"
.IX Subsection "_map"
.Vb 1
\&    return $self\->_map(\*(Aqbib1_field_map\*(Aq, $map);
.Ve
.PP
Retrieves or sets a map.
.SS "_add_mapping"
.IX Subsection "_add_mapping"
.Vb 1
\&    return $self\->_add_mapping($map, $name, $server, $attributes)
.Ve
.PP
Adds a mapping. Note that this is not used for mappings relating to fields.
.SS "_add_field_mapping"
.IX Subsection "_add_field_mapping"
.Vb 1
\&    return $self\->_add_field_mapping($map, $class, $field, $server, $attributes)
.Ve
.PP
Adds a mapping for field-related data.
.SS "bib1_mapping_by_name"
.IX Subsection "bib1_mapping_by_name"
.Vb 3
\&    my $attributes = $QParser\->bib1_mapping_by_name($type, $name[, $subname], $server);
\&    my $attributes = $QParser\->bib1_mapping_by_name(\*(Aqfield\*(Aq, \*(Aqauthor\*(Aq, \*(Aqpersonal\*(Aq, \*(Aqbiblioserver\*(Aq);
\&    my $attributes = $QParser\->bib1_mapping_by_name(\*(Aqfilter\*(Aq, \*(Aqpubdate\*(Aq, \*(Aqbiblioserver\*(Aq);
.Ve
.PP
Retrieve the Bib\-1 attribute set associated with the specified mapping.
.SS "bib1_mapping_by_attr"
.IX Subsection "bib1_mapping_by_attr"
.Vb 4
\&    my $field = $QParser\->bib1_mapping_by_attr($type, $server, \e%attr);
\&    my $field = $QParser\->bib1_mapping_by_attr(\*(Aqfield\*(Aq, \*(Aqbiblioserver\*(Aq, {\*(Aq1\*(Aq => \*(Aq1004\*(Aq});
\&    print $field\->{\*(Aqclassname\*(Aq}; # prints "author"
\&    print $field\->{\*(Aqfield\*(Aq}; # prints "personal"
.Ve
.PP
Retrieve the search field/modifier/filter used for the specified Bib\-1 attribute set.
.SS "bib1_mapping_by_attr_string"
.IX Subsection "bib1_mapping_by_attr_string"
.Vb 4
\&    my $field = $QParser\->bib1_mapping_by_attr_string($type, $server, $attr_string);
\&    my $field = $QParser\->bib1_mapping_by_attr_string(\*(Aqfield\*(Aq, \*(Aqbiblioserver\*(Aq, \*(Aq@attr 1=1004\*(Aq);
\&    print $field\->{\*(Aqclassname\*(Aq}; # prints "author"
\&    print $field\->{\*(Aqfield\*(Aq}; # prints "personal"
.Ve
.PP
Retrieve the search field/modifier/filter used for the specified Bib\-1 attribute string
(i.e. \s-1PQF\s0 snippet).
.SS "clear_all_configuration"
.IX Subsection "clear_all_configuration"
.Vb 1
\&    $QParser\->clear_all_configuration
.Ve
.PP
Clear all configuration. This is a highly destructive method. You may
not want to use it.
.SS "clear_all_mappings"
.IX Subsection "clear_all_mappings"
.Vb 1
\&    $QParser\->clear_all_mappings
.Ve
.PP
Clear all bib\-1 mappings.
.SS "_canonicalize_field_map"
.IX Subsection "_canonicalize_field_map"
Convert a field map into its canonical form for serialization. Used only for
fields and relevance bumps.
.SS "_canonicalize_map"
.IX Subsection "_canonicalize_map"
Convert a map into its canonical form for serialization. Not used for fields.
.SS "serialize_mappings"
.IX Subsection "serialize_mappings"
.Vb 2
\&    my $yaml = $QParser\->serialize_mappings;
\&    my $json = $QParser\->serialize_mappings(\*(Aqjson\*(Aq);
.Ve
.PP
Serialize Bib\-1 mappings to \s-1YAML\s0 or \s-1JSON\s0.
.SS "initialize"
.IX Subsection "initialize"
.Vb 5
\&    $QParser\->initialize( { \*(Aqbib1_field_mappings\*(Aq => \e%bib1_field_mappings,
\&                            \*(Aqsearch_field_alias_mappings\*(Aq => \e%search_field_alias_mappings,
\&                            \*(Aqbib1_modifier_mappings\*(Aq => \e%bib1_modifier_mappings,
\&                            \*(Aqbib1_filter_mappings\*(Aq => \e%bib1_filter_mappings,
\&                            \*(Aqrelevance_bumps\*(Aq => \e%relevance_bumps });
.Ve
.PP
Initialize the QueryParser mapping tables based on the provided configuration.
This method was written to play nice with \s-1YAML\s0 configuration files loaded by load_config.
.SS "load_config"
.IX Subsection "load_config"
.Vb 1
\&  $QParser\->load_config($file_name);
.Ve
.PP
Load a \s-1YAML\s0 file with a parser configuration. The \s-1YAML\s0 file should match the following format:
.PP
.Vb 10
\&    \-\-\-
\&    field_mappings:
\&      author:
\&        "":
\&          aliases:
\&            \- au
\&          bib1_mapping:
\&            biblioserver:
\&              1: 1003
\&          enabled: 1
\&          index: \*(Aq\*(Aq
\&          label: \*(Aq\*(Aq
\&        conference:
\&          aliases:
\&            \- conference
\&            \- cfn
\&          bib1_mapping:
\&            biblioserver:
\&              1: 1006
\&          enabled: 1
\&          index: conference
\&          label: Conference
\&    filter_mappings:
\&      acqdate:
\&        bib1_mapping:
\&          biblioserver:
\&            1: Date\-of\-acquisition
\&            4: 4
\&            target_syntax_callback: date_filter_target_callback
\&        enabled: 1
\&        label: Acqdate
\&    modifier_mappings:
\&      AuthidAsc:
\&        bib1_mapping:
\&          authorityserver:
\&            "": 0
\&            1: Local\-Number
\&            7: 1
\&            op: "@or"
\&        enabled: 1
\&        label: AuthidAsc
\&    ...
.Ve
.SS "\s-1TEST_SETUP\s0"
.IX Subsection "TEST_SETUP"
.Vb 1
\&    $QParser\->TEST_SETUP
.Ve
.PP
This routine initializes the QueryParser driver with a reasonable set of
defaults. This is intended only for testing. Although such test stubs are
generally not included in Koha, this type of test stub is used by other
QueryParser implementations, and it seems sensible to maintain consistency
as much as possible.
